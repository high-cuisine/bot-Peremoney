import { Injectable } from '@nestjs/common'
import { Action, Ctx, Scene, SceneEnter, On, Command } from 'nestjs-telegraf'
import { AdminService } from 'src/modules/admin/admin.service'
import { Markup } from 'telegraf'
import { SceneContext } from 'telegraf/typings/scenes'

//import { BotMessage, getTelegramMessage } from 'src/util/bot_messages'

interface RegisterSession {
  name?: string
  phone?: string
  step: 'name' | 'phone' | 'confirmation'
}

@Injectable()
@Scene('register')
export class RegisterScene {
  constructor(
  ) {}

  @SceneEnter()
  async registerEnter(@Ctx() ctx: SceneContext) {
    await ctx.replyWithHTML(
      '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø—Ä–æ—Ü–µ—Å—Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏! üëã\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è:'
    )
  }

  @On('text')
  async onMessage(@Ctx() ctx: SceneContext) {
   
    if (!ctx.scene || ctx.scene.current.id !== 'register') {
      return
    }

    const session = ctx.session['register'] as RegisterSession
    if (!session) {
      await ctx.scene.leave()
      return
    }

    const text = ctx.message['text']

    switch (session.step) {
      case 'name':
        if (text.length < 2) {
          await ctx.replyWithHTML('‚ùå –ò–º—è –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:')
          return
        }
        session.name = text
        session.step = 'phone'
        await ctx.replyWithHTML('‚úÖ –û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ +7XXXXXXXXXX:')
        break

      case 'phone':
        const phoneRegex = /^\+7\d{10}$/
        if (!phoneRegex.test(text)) {
          await ctx.replyWithHTML(
            '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç +7XXXXXXXXXX:'
          )
          return
        }
        session.phone = text
        session.step = 'confirmation'

        await ctx.replyWithHTML(
          `üìù –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–≤–µ–¥–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:\n\n` +
          `üë§ –ò–º—è: <b>${session.name}</b>\n` +
          `üì± –¢–µ–ª–µ—Ñ–æ–Ω: <b>${session.phone}</b>\n\n` +
          `–í—Å–µ –≤–µ—Ä–Ω–æ?`,
          Markup.inlineKeyboard([
            [
              Markup.button.callback('‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', 'confirm_registration'),
              Markup.button.callback('üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ', 'restart_registration')
            ]
          ])
        )
        break
    }
  }

  

  @Action('restart_registration')
  async onRestart(@Ctx() ctx: SceneContext) {
    if (!ctx.scene || ctx.scene.current.id !== 'register') {
      return
    }

    // –†–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Å—Å–∏—é
    ctx.session['register'] = {
      step: 'name'
    }

    await ctx.answerCbQuery()
    await ctx.scene.reenter()
  }

  @Action('cancel')
  async onCancel(@Ctx() ctx: SceneContext) {
    if (!ctx.scene || ctx.scene.current.id !== 'register') {
      return
    }

    await ctx.replyWithHTML('‚ùå –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.')
    await ctx.scene.leave()
  }

  @Command('exit')
  async onExit(@Ctx() ctx: SceneContext) {
    await ctx.reply('–í—ã—Ö–æ–¥ –∏–∑ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏');
    await ctx.scene.leave();
  }
}
